= Recorded Future API =

== version 1.0.0 ==

Contents

    # *1 *[version 1.0.0#version_1.0.0]
    # <a href="#TOC-Introduction">*2 *Introduction</a>
        # <a href="#TOC-Quick-Start:-Creating-Requests.">*2.1 *Quick Start: Creating Requests.</a>
    # <a href="#TOC-Input-and-Output-in-JSON">*3 *Input and Output in JSON</a>
    # <a href="#TOC-Query-specification">*4 *Query specification</a>
        # <a href="#TOC-Matching-on-instance-identity-or-ty">*4.1 *Matching on instance identity or type</a>
        # <a href="#TOC-Matching-on-instance-time">*4.2 *Matching on instance time</a>
        # <a href="#TOC-Matching-on-the-canonical-item">*4.3 *Matching on the canonical item</a>
        # <a href="#TOC-Matching-on-attributes">*4.4 *Matching on attributes</a>
        # <a href="#TOC-Matching-on-document-and-source-asp">*4.5 *Matching on document and source aspects</a>
        # <a href="#TOC-Output-fields">*4.6 *Output fields</a>
        # <a href="#TOC-Entity-details">*4.7 *Entity details</a>
        # <a href="#TOC-Response-specification">*4.8 *Response specification</a>
    # <a href="#TOC-Aggregate-Queries">*5 *Aggregate Queries</a>
    # <a href="#TOC-Examples">*6 *Examples</a>
        # <a href="#TOC-Query-Examples">*6.1 *Query Examples</a>
        # <a href="#TOC-Response-Example">*6.2 *Response Example</a>
    # <a href="#TOC-Working-with-the-API-in-the-Recorde">*7 *Working with the API in the Recorded Future UI</a>
    # <a href="#TOC-Using-the-Recorded-Future-API-with-">*8 *Using the Recorded Future API with R</a>
    # <a href="#TOC-Using-the-Recorded-Future-API-with-1">*9 *Using the Recorded Future API with Python</a>
    # <a href="#TOC-Entity-and-Event-Types">*10 *Entity and Event Types</a>
        # <a href="#TOC-Entity-Types">*10.1 *Entity Types</a>
        # <a href="#TOC-Event-Types">*10.2 *Event Types</a>

== Introduction ==

The Recorded Future’s API enables you to build analytic applications and perform analysis which is aware of events happening around the globe 24x7, with extensive historical records. You can perform queries and receive results from the Recorded Future Temporal Analytics Engine across a vast set of events, entities, and time points spanning from the far past into the future.

Your application can come alive with real time access into the Recorded Future engine, completely aware of events as they unfold around the world - and your analysis of for example financial markets can be made aware of events involving companies, people, products, etc. Historical archives allows you to extensively backtest results.

Sample applications and analysis built/done with the Recorded Future API include
    * Interactive dashboards of global events
    * Google earth overlay of global events
    * Back testing whether FT Alphaville (high profile financial blog) is "better" than general news in predicting stock returns
    * Back testing whether Recorded Future momentum metric accurately predicts equity trading volume

To access Recorded Future through the API:
    # Request a Recorded Future API token.
    # Create a structured JSON string that describes the query.
    # Create and submit the associated URL.
    # Retrieve and parse the results.

=== Quick Start: Creating Requests. ===

Queries are sent using HTTP GET to
	[http://api.recordedfuture.com/ws/rfq/instances?q=query&compress=usecompression http://api.recordedfuture.com/ws/rfq/instances?q=query&compress=usecompression]
    
Zip compression is enabled if the optional attribute compress=usecompression. If the attribute is not set, no compression is used.

Note: Queries can also be sent using HTTP POST. Do this if the query string becomes too long (typically, there is a limit on a few thousand characters for GET requests).


Queries and responses are expressed in JSON.

The following sample query looks for Product Release events from companies within the Information Technology sector, published in January 2010. The 100 first results are returned.


{{{
{
  "instance": {
    "type": ["ProductRelease"],
    "attributes": [{"name": "company",
                    "entity": {"attributes": [{"name": "gics",
                                               "string": "Information Technology"}]}}],
    "document": {
      "published": {"min": "2010-01-01", "max": "2010-02-01"}
    },
    "limit": 100
  },
  "output": {
    "fields": ["type", "time", "fragment", "momentum", "attributes",
               "document.title", "document.url", "document.published", "source.description"]
  },
  "token": TOKEN
}
}}}


The following sample result is part of the response to the query, which contains information about one event instance. The result contains information about the event (an announced product release), the text fragment it was found in (“Microsoft launches tech policy Web site.”), the document source (Federal Computer Week News), the document it was found in (The URL that displays the actual document), and the current momentum value.

{{{
{
  "fragment": "Microsoft launches tech policy Web site.",
  "stop": "2010-01-06T17:13:31.000Z",
  "start": "2010-01-06T17:13:31.000Z",
  "attributes": {
    "status": "announced",
    "company": 33312449,
    "product_type": "Other",
    "product": 33434006
  },
  "document": {
    "url": "http://fcw.com/articles/2010/01/06/microsoft-web-technology-policy.aspx",
    "source": {
      "description": "Federal Computer Week News"
    },
    "published": "2010-01-06T17:13:31.000Z",
    "title": "Microsoft launches tech policy Web site"
  },
  "type": "ProductRelease",
  "momentum": 0.044266346260364201
}
}}}


Entities – the people, companies, organizations, and places of the Recorded Future Who/Where list – are created on-demand as they are harvested by a query. Once an entity is defined, all references to that entity are defined as entity instances that point to the underlying canonical entity. Once an entity is defined, all references to that entity are defined as entity instances that point to the underlying canonical entity. Entities are returned in a separate structure, to avoid duplication, and in the instances only references to the entities are present, using an opaque identifier. For example, in the attributes section above there is a company with the identifier 33312449. In the entity structure, there is an parameter for that identifier:
{{{
    "33312449": {
      "type": "Company",
      "name": "Microsoft",
      "momentum": 0.72911597000853101
    }
}}}

For details about the exact query and response structures, see the “Query Specification” and “Response Specification” sections.

== Input and Output in JSON ==

The Recorded Future API supports JSON as the input and output format. For a detailed JSON specification, visit Douglas Crockford’s site [http://www.json.org/ JSON.org], paying particular attention to [http://tools.ietf.org/html/rfc4627 RFC 4627]. This section provides a short excerpt.
*Tip*: If you are using [http://www.r-project.org R], you don’t need to worry about formatting JSON input or parsing JSON output. R packages manage input and output for you. See “Using the Recorded Future API with R” to learn more.
*JSON* (JavaScript Object Notation) is a lightweight data-interchange format. It is easy for humans to read and write. It is easy for machines to parse and generate. JSON is a text format that is completely language independent but uses conventions that are familiar to programmers of the C-family of languages, including C, C++, C#, Java, JavaScript, Perl, Python, and many others. These properties make JSON an ideal data-interchange language.
JSON is built on two structures:

	* A collection of name/value pairs. In various languages, this is realized as an _object_, record, struct, dictionary, hash table, keyed list, or associative array.
	* An ordered list of values. In most languages, this is realized as an _array_, vector, list, or sequence.

These are universal data structures. Virtually all modern programming languages support them in one form or another. It makes sense that a data format that is interchangeable with programming languages also be based on these structures.
In JSON, which always uses Unicode encoding, they take on these forms:

	* An _object_ is an unordered set of name/value pairs. An object begins with { <font size="1">(left brace)</font> and ends with } <font size="1">(right brace)</font>. Each name is followed by : <font size="1">(colon)</font> and the name/value pairs are separated by , <font size="1">(comma)</font>.
	* An _array_ is an ordered collection of values. An array begins with `[` <font size="1">(left bracket)</font> and ends with `]` <font size="1">(right bracket)</font>. Values are separated by , <font size="1">(comma)</font>.
	* A _value_ can be a _string_ in double quotes, or a _number_, or true or false or null, or an _object_ or an _array_. These structures can be nested.
	* A _string_ is a collection of zero or more Unicode characters, wrapped in double quotes, using backslash escapes. A character is represented as a single character string. A string is very much like a C or Java string.
	* A _number_ is very much like a C or Java number, except that the octal and hexadecimal formats are not used.
	* Whitespace can be inserted between any pair of tokens.

== Query specification ==

Queries are given as the q parameter in the API URL. They need to be [http://en.wikipedia.org/wiki/URL_encoding URL encoded].

A query has the following structure:

{{{
{
  "comment": <string> (optional),
  "instance": <instance_spec>,
  "output": <output_spec>,
  "token": <string>
}
}}}

The optional _comment_ section can be used to document a question in human readable form. It is not used in the query.

The _instance_ section specifies conditions that must be true for all returned instances.

{{{
"instance": {
    "id": [integer],
    "type": [string],
    "start_time": time-spec,
    "stop_time": time-spec,
    "canonical": canonical-constraints,
    "attributes": attributes-constraints,
    "document": document-constraints,
    "limit": integer
}
}}}

=== Matching on instance identity or type ===

_id_ matches on instance identifiers. An identifier is a long integer, and is a system defined identification of the instance. You’ll usually match on instance identifiers only when you’re looking for detailed instance information using identifiers returned in the results of earlier queries.The value of _id_ must be an integer or a list of integers. _id_ matches if the instance identifier matches one of the provided identifiers.

_type_ matches on the names of the canonical types of instances. The canonical types are the event types and entity types in the system, as described by the system metadata specification. The value of _type_ must be a string or a list of strings. _type_ matches if the name of the canonical type of the instance is one of the supplied instance type names. A list of all current entity and event types is available at the end of this document.

=== Matching on instance time ===

_start`_`time_ specifies the minimum time of the instance start time and must be a string formatted as YYYY-MM-DD.

_stop`_`time_ specifies the maximum time of the instance stop time and must be a string formatted as YYYY-MM-DD.

=== Matching on the canonical item ===

The canonical parameter matches on aspects of the instance's canonical item. The aspects are specified using the structure:

{{{
"canonical": {
    "id": [integer],
    "name": [string]
}
}}}

_id_ matches on canonical identifiers. An identifier is a long integer, and is a system defined identification of the canonical item. The value must be an integer or a list of integers. The value matches if the canonical identifier matches one of the provided identifiers.
You’ll usually match on canonical identifiers only when you’re looking for detailed instance information using identifiers returned in the results of earlier queries.

_name matches on canonical names. Only canonical entities have names; canonical events do not. The value of _name_ must be a string or a list of strings. The parameter matches if the canonical name identifier matches one of the supplied names.

=== Matching on attributes ===

The attributes parameter matches on the attributes of the instance. The attributes section is a list of match criteria for attributes, and all entries in the list must match, in order for an instance to match. Attributes are identified by name or by type. Named attributes can be used only if a distinct type constraint has been set in the query, then all attributes of the typed item are available to be referenced by name. Typed attributes match all attributes of an item with that type. The structure of an attribute match is:

{{{
{
  name-or-type,
  value-constraint
}
}}}
The _name-or-type_ part is either "name": _attribute-name_ or "type": _type_. The _value-constraint_ part is type dependent. Here is the list of different types, and how to match on them:

{{{
"string":  [string]
"int":     [integer]
"float":   [float]
"bool":    [bool]
"entity":  entity-match
}}}

Matching for the string, integer, float, and Boolean are all of the form that a single value or a list of values of the specified type. If a list is supplied, a match is found if any element of the list matches. For entity matches, the structure is a subset of the structure for entity instances, excluding the time and document constraints.

{{{
"entity": {
    "id": [integer],
    "name": [string],
    "attributes": attributes-constraints
}
}}}

_id_ matches on the canonical entity identifier
_name_ matches on canonical entity name.
_attributes_ recursively matches on entity attributes, as described in this section.

=== Matching on document and source aspects ===

_document_ matches on aspects of the document in which the instance was found, or aspects of the source the document was received from. It has the following structure:

{{{
"document": {
    "id": [integer],
    "published": time-range,
    "analyzed": time-range,
    "downloaded": time-range,
    "url": string,
    "source": source-constraints
}
}}}

_id_ matches on document identifiers. An identifier is a long integer, and is a system defined identification of the document. The value of the parameter must be an integer or a list of integers. The parameter matches if the document identifier matches one of the provided identifiers. You’ll usually match on document identifiers only when you’re looking for detailed instance information using identifiers returned in the results of earlier queries.

_published_ matches on the publication date of the document. The value is a time-range structure:</div>

{{{
{
    "min": time-spec,
    "max": time-spec
}
}}}

If _published_ is not specified, there is no constraint on the document publication time. If _min_ is specified, the publication time must not be earlier than the given time. If _max_ is specified, the publication time must not be later than the given time. The time must be specified as a string with the date format YYYY-MM-DD.

_analyzed_ matches on the date Recorded Future analyzed the document. _analyzed_ has the same structure as _published_.

_downloaded_ matches on the date Recorded Future downloaded the document. _downloaded_ has the same structure as _published_.

_url_ matches on the URL of the document. The value of the entry must be a string or a list of strings. The entry matches if the document URL matches one of the provided URLs.

The source constraint has the following structure:

{{{
"source": {
    "id": [integer],
    "name": [string],
    "description": [string],
    "topic": [string],
    "media_type": [string],
    "country": [string],
    "url": [string],
    "limit": [integer]
}
}}}

_id_ matches on source identifiers. An identifier is a long integer, and is a system defined identification of a source. The value of the parameter must be an integer or a list of integers. The parameter matches if the source identifier matches one of the provided identifiers.

_name_ matches on source name. A source name is a short string identifying the source. The value of the parameter must be a string or a list of strings. The parameter matches if the source name matches one of the supplied names.

_description_ matches on source descriptions. A source description is a somewhat longer string identifying the source. The value of the parameter must be a string or a list of strings. The parameter matches if the source description matches one of the provided names.

_topic_ matches on source topics. (Recorded Future categorizes all Sources into topics.) The value of the parameter must be a string or a list of strings. The parameter matches if the source topic matches one of the following names:

{{{
Business
Technology
General
Geopolitical
Energy
Legal
Healthcare
Government
Military
Financial services
Health care
Humanitarian
Environment
InfoSec
terrorism
disease
health
ISVG
Malware
}}}

_media`_`type_ matches on source media types. (The system categorizes all Sources into media types.) The value of the parameter must be a string or a list of strings. _media`_`type_ matches if the source media type matches one of the following names:

{{{
Blog
Niche
Mainstream
Government
NGO
News_agency
Exchange
Primary_source
DataProvider
}}}

_country_ matches on the originating country of the source. The value of _country_ must be a string or a list of strings. _country_ matches if the source country matches one of the country names specified in the metadata document.

_url_ matches on the URL of the source. The value of _url_ must be a string  or a list of strings. _url_ matches if the source URL matches one of the provided names.

_limit_ specifies the maximum number of instances in the response. The value of _limit_ must be an integer.

=== Output fields ===

The _output_ fields shape the query response.