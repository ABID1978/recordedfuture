= Recorded Future API =

== version 2.0.0 ==

Contents

*1 *[#version_2.0.0 version2.0.0]<br>
*2 *[#Introduction Introduction]<br>
<font color="white">`  .  `</font>*2.1 *[#Quick_Start:_Creating_Requests. Quick Start: Creating Requests.]<br>
*3 *[#Input_and_Output_in_JSON Input and Output in JSON]<br>
*4 *[#Entity_queries Entity query specification]<br>
*5 *[#Source_queries Source query specification]<br>
*6 *[#Instance_query_specification Instance query specification]<br>
<font color="white">`  .  `</font>*4.1 *[#Matching_on_instance_identity_or_type Matching on instance identity or type]<br>
<font color="white">`  .  `</font>*4.2 *[#Matching_on_instance_time Matching on instance time]<br>
<font color="white">`  .  `</font>*4.3 *[#Matching_on_the_canonical_item Matching on the canonical item]<br>
<font color="white">`  .  `</font>*4.4 *[#Matching_on_attributes Matching on attributes]<br>
<font color="white">`  .  `</font>*4.5 *[#Matching_on_document_and_source_aspects Matching on document and source aspects]<br>
<font color="white">`  .  `</font>*4.6 *[#Matching_on_free_text Matching on free text features]<br>
<font color="white">`  .  `</font>*4.7 *[#Response_specification Response specification]<br>
*7 *[#Output_fields Output fields]<br>
*8 *[#Aggregate_Queries Aggregate Queries]<br>
*9 *[#On_the_fly_aggregation On the fly aggregation]<br>
*10 *[#Paging_instance_results Paging Instance Results]<br>
*11 *[#Examples Examples]<br>
<font color="white">`  .  `</font>*6.1 *[#Query_Examples Query Examples]<br>
<font color="white">`  .  `</font>*6.2 *[#Response_Example Response Example]<br>
*12 *[#Working_with_the_API_in_the_Recorded_Future_UI Working with the API in the Recorded Future UI]<br>
*13 *[#Using_the_Recorded_Future_API_with_R Using the Recorded Future API with R]<br>
*14 *[#Using_the_Recorded_Future_API_with_Python Using the Recorded Future API with Python]<br>
*15 *[#Entity_and_Event_Types Entity and Event Types]<br>
<font color="white">`  .  `</font>*10.1 *[#Entity_Types Entity Types]<br>
<font color="white">`  .  `</font>*10.2 *[#Event_Types Event Types]<br>

== Introduction ==

The Recorded Future’s API enables you to build analytic applications and perform analysis which is aware of events happening around the globe 24x7, with extensive historical records. You can perform queries and receive results from the Recorded Future Temporal Analytics™ Engine across a vast set of events, entities, and time points spanning from the far past into the future.

Your application can come alive with real time access into the Recorded Future engine, completely aware of events as they unfold around the world - and your analysis of for example financial markets can be made aware of events involving companies, people, products, etc. Historical archives allows you to extensively backtest results.

Sample applications and analysis built/done with the Recorded Future API include
    * Interactive dashboards of global events
    * Google earth overlay of global events
    * Back testing whether FT Alphaville (high profile financial blog) is "better" than general news in predicting stock returns
    * Backtesting news-based trading strategies for sources of uncorrelated alpha.

To access Recorded Future through the API:
    # Request a Recorded Future API token.
    # Create a structured JSON string that describes the query.
    # Create and submit the associated URL.
    # Retrieve and parse the results.

=== Quick Start: Creating Requests. ===

Queries are sent using HTTPS GET or POST to
	[https://api.recordedfuture.com/query https://api.recordedfuture.com/query]
    
Query parameters should be with the key "q" and a JSON-encoded query object as its value.

Data will be gzipped with HTTPS content encoding if requested by the client by setting the the HTTPS "Accept-encoding" header to "gzip".

Queries are expressed in JSON. Output is expressed in JSON or CSV.

The following sample query looks for Cyber Attack events related to the Syrian Electronic Army, published in January 2015. The first 100 results are returned.


{{{
{
  "instance": {
    "type": ["CyberAttack"],
    "attributes": {
      "entity": {
        "id":"BFHu9W"
      }
    },
    "document": {
      "published": {"min": "2015-01-01", "max": "2015-01-31"}
    },
    "limit": 100
  },
  "token": "TOKEN"
}
}}}


The following sample result is part of the response to the query, which contains information about one event instance. The result contains information about the event (a cyber attack), the text fragment it was found in (“French newspaper Le Monde's Twitter account suffers hacking attack”), the document source (IBTimes UK), and the document it was found in (the URL that displays the actual document).

{{{
        {
            "id": "GUgYXSAqFHT",
            "type": "CyberAttack",
            "cluster_ids": [
                "C0bYw9girdQ"
            ],
            "start": "2015-01-21T06:21:06.000Z",
            "stop": "2015-01-21T06:21:06.000Z",
            "tagged_fragment": "Signs of <i id=GUgYXSAqFHT>hacking came after 7:00 pm ET, as the logo of the <e id=BFHu9W>Syrian Electronic Army</e></i> was seen in a tweet sent from the official <e id=I2M5pa>Le Monde</e> account.",
            "fragment": "Signs of hacking came after 7:00 pm ET, as the logo of the Syrian Electronic Army was seen in a tweet sent from the official Le Monde account.",
            "item_fragment": "hacking came after 7:00 pm ET, as the logo of the Syrian Electronic Army",
            "precision": "ms",
            "time_type": "in",
            "document": {
                "id": "M8bkbW",
                "title": "\n\nFrench newspaper Le Monde's Twitter account suffers hacking attack\n",
                "url": "http://www.ibtimes.co.uk/french-newspaper-le-mondes-twitter-account-suffers-hacking-attack-1484357",
                "language": "eng",
                "published": "2015-01-21T06:21:06.000Z",
                "downloaded": "2015-01-21T06:21:23.796Z",
                "indexed": "2015-01-21T06:21:43.120Z",
                "sourceId": {
                    "id": "K3hhZz",
                    "name": "IBTimescouk  Europe",
                    "description": "Europe  Feed",
                    "media_type": "JxSEs2",
                    "country": "United Kingdom",
                    "topic": "JxSEs3"
                }
            },
            "attributes": {
                "indicator": "hacking came after 7:00 pm ET , as the logo of the Syrian Electronic Army",
                "general_negative": 0,
                "function": "id",
                "document_category": "Cyber",
                "canonic_id": "C_1bJjzhPM5",
                "extended_entities": [
                    "0f-N9",
                    "C3Oxl8"
                ],
                "analyzed": "2015-01-21T06:21:43.031Z",
                "attacker": "BFHu9W",
                "positive": 0,
                "sentiments": {
                    "general_positive": 0,
                    "violence": 0,
                    "activism": 0,
                    "general_negative": 0,
                    "negative": 0,
                    "positive": 0,
                    "profanity": 0
                },
                "violence": 0,
                "document_external_id": "http://www.ibtimes.co.uk/french-newspaper-le-mondes-twitter-account-suffers-hacking-attack-1484357",
                "binning_id": "C_1bJjzhPM5",
                "entities": [
                    "BFHu9W",
                    "I2M5pa"
                ],
                "general_positive": 0,
                "hits": 0,
                "topics": [
                    "KPzZCG",
                    "KPzZAE"
                ],
                "negative": 0,
                "fragment_count": 1
            }
        }
}}}


Entities – the people, companies, organizations, and places of the Recorded Future Who/Where list – are created on-demand as they are harvested by a query. Once an entity is defined, all references to that entity are defined as entity instances that point to the underlying canonical entity. Entities are returned in a separate structure, to avoid duplication, and in the instances only references to the entities are present, using an opaque identifier. 

For details about the exact query and response structures, see the “Query Specification” and “Response Specification” sections.

== Input and Output in JSON ==

The Recorded Future API supports JSON as the input and output format. For a detailed JSON specification, visit Douglas Crockford’s site [http://www.json.org/ JSON.org], paying particular attention to [http://tools.ietf.org/html/rfc4627 RFC 4627]. This section provides a short excerpt.

*Tip*: If you are using [http://www.r-project.org R], you don’t need to worry about formatting JSON input or parsing JSON output. R packages manage input and output for you. See “Using the Recorded Future API with R” to learn more.

*JSON* (JavaScript Object Notation) is a lightweight data-interchange format. It is easy for humans to read and write. It is easy for machines to parse and generate. JSON is a text format that is completely language independent but uses conventions that are familiar to programmers of the C-family of languages, including C, C++, C#, Java, JavaScript, Perl, Python, and many others. These properties make JSON an ideal data-interchange language.
JSON is built on two structures:

	* A collection of name/value pairs. In various languages, this is realized as an _object_, record, struct, dictionary, hash table, keyed list, or associative array.
	* An ordered list of values. In most languages, this is realized as an _array_, vector, list, or sequence.

These are universal data structures. Virtually all modern programming languages support them in one form or another. It makes sense that a data format that is interchangeable with programming languages also be based on these structures.
In JSON, which always uses Unicode encoding, they take on these forms:

	* An _object_ is an unordered set of name/value pairs. An object begins with { <font size="1">(left brace)</font> and ends with } <font size="1">(right brace)</font>. Each name is followed by : <font size="1">(colon)</font> and the name/value pairs are separated by , <font size="1">(comma)</font>.
	* An _array_ is an ordered collection of values. An array begins with `[` <font size="1">(left bracket)</font> and ends with `]` <font size="1">(right bracket)</font>. Values are separated by , <font size="1">(comma)</font>.
	* A _value_ can be a _string_ in double quotes, or a _number_, or true or false or null, or an _object_ or an _array_. These structures can be nested.
	* A _string_ is a collection of zero or more Unicode characters, wrapped in double quotes, using backslash escapes. A character is represented as a single character string. A string is very much like a C or Java string.
	* A _number_ is very much like a C or Java number, except that the octal and hexadecimal formats are not used.
	* Whitespace can be inserted between any pair of tokens.
	
	
== Entity query specification ==

Entity queries allow users to look up an identifier for an entity in the Recorded Future system. We support entity lookup by name or free text search. Entity IDs are used to query the system for information related to specific entities. 

An entity query has the following structure:

{{{
{
  "comment": <string> (optional),
  "entity": <entity_spec>,
  "token" <string>
}
}}}

The _entity_ section specifies conditions that must be true for all returned entities.

{{{
"entity": {
  "id": [string] (optional),
  "type": [string] (optional),
  "name": [string] (optional),
  "freetext": <freetext_spec> (optional)
}
}}} 

The following query will look up the entity information for Edward Snowden:
{{{
{
  "entity": {
    "type": "Person",
    "name": "Edward Snowden"
  },
  "token": "TOKEN"
}
}}}

The response will look like this:
{{{
{
    "count": {
        "entities": {
            "returned": 1,
            "total": 1
        }
    },
    "next_page_start": "1",
    "status": "SUCCESS",
    "entities": [
        "J5K1uB"
    ],
    "entity_details": {
        "J5K1uB": {
            "name": "Edward Snowden",
            "hits": 3477157,
            "type": "Person",
            "alias": [
                "Сноудене",
                "إدوراد سنودن",
                "ادوارد اسنودن",
                "Edward Joseph Snowden",
                "ادورد سنودن"
            ],
            "curated": 1,
            "gender": "male",
            "id": "J5K1uB"
        }
    }
}
}}}

== Source query specification ==

Source queries allow users to look up an identifier for a source in the Recorded Future system. We support entity source by id, name, media type, topic, and country.

A source query has the following structure:

{{{
{
  "comment": <string> (optional),
  "source": <source_spec>,
  "token" <string>
}
}}}

The _source_ section specifies conditions that must be true for all returned sources.

{{{
"source": {
  "id": [string] (optional),
  "media_type": [string] (optional),
  "name": [string] (optional),
  "topic": [string] (optional)
}
}}} 

The following query will return source information for Business Blogs:

{{{
{
  "source": {
    "topic": "KPzZAT",
    "media_type": "JxSDuU",
    "limit": 20
  },
  "token": "TOKEN"
}
}}}

The response will look like this:

{{{
{
    "status": "SUCCESS",
    "sources": {
        "LRAE8g": {
            "media_type": "JxSDuU",
            "created": "2014-07-07T21:23:55.442Z",
            "location": "B_FAG",
            "name": "Forbes"
        },
    ...
}
}}}


== Instance query specification ==

Instance queries are given as the q parameter in the API URL. They need to be [http://en.wikipedia.org/wiki/URL_encoding URL encoded].

A query has the following structure:

{{{
{
  "comment": <string> (optional),
  "instance": <instance_spec>,
  "output": <output_spec> (optional),
  "token": <string>
}
}}}

The optional _comment_ section can be used to document a question in human readable form. It is not used in the query.

The _instance_ section specifies conditions that must be true for all returned instances.

{{{
"instance": {
    "id": [string],
    "type": [string],
    "start_time": time-spec,
    "stop_time": time-spec,
    "canonical": canonical-constraints,
    "attributes": attributes-constraints,
    "document": document-constraints,
    "freetext": [freetext-constraints],
    "limit": integer
}
}}}

=== Matching on instance identity or type ===

_id_ matches on instance identifiers. An identifier is a string, and is a system defined identification of the instance. You’ll usually match on instance identifiers only when you’re looking for detailed instance information using identifiers returned in the results of earlier queries.The value of _id_ must be an string or a list of strings. _id_ matches if the instance identifier matches one of the provided identifiers.

_type_ matches on the names of the canonical types of instances. The canonical types are the event types and entity types in the system, as described by the system metadata specification. The value of _type_ must be a string or a list of strings. _type_ matches if the name of the canonical type of the instance is one of the supplied instance type names. A list of all current entity and event types is available [#Entity_and_Event_Types at the end of this document].

=== Matching on instance time ===

_start`_`time_ specifies the minimum time of the instance start time. The time must be specified as a string with the date format YYYY-MM-DD or YYYY-MM-DDTHH:MM:SS.000Z in UTC. It is possible to specify time with only initial portions of the time specification. That is, a timestamp can be specified as "2012-05" to indicate May, 2012, or "2012-05-01 12:00" to indicate noon, UTC on 2012-05-01.


_stop`_`time_ specifies the maximum time of the instance stop time and must be a string formatted according to the same rules as _start`_`time_.

=== Matching on the canonical item ===

The canonical parameter matches on aspects of the instance's canonical item. The aspects are specified using the structure:

{{{
"canonical": {
    "id": [string],
    "name": [string]
}
}}}

_id_ matches on canonical identifiers. An identifier is a string, and is a system defined identification of the canonical item. The value must be a string or a list of strings. The value matches if the canonical identifier matches one of the provided identifiers.

You’ll usually match on canonical identifiers only when you’re looking for detailed instance information using identifiers returned in the results of earlier queries.

_name matches on canonical names. Only canonical entities have names; canonical events do not. The value of _name_ must be a string or a list of strings. The parameter matches if the canonical name identifier matches one of the supplied names.

=== Matching on attributes ===

The attributes parameter matches on the attributes of the instance. The attributes section is a list of match criteria for attributes, and all entries in the list must match, in order for an instance to match. Attributes are identified by name or by type. Named attributes can be used only if a distinct type constraint has been set in the query, then all attributes of the typed item are available to be referenced by name. Typed attributes match all attributes of an item with that type. The structure of an attribute match is:

{{{
{
  name-or-type,
  value-constraint
}
}}}

The _name-or-type_ part is either "name": _attribute-name_ or "type": _type_. The _value-constraint_ part is type dependent. Here is the list of different types, and how to match on them:

{{{
"string":  [string]
"int":     [integer]
"float":   [float]
"bool":    [bool]
"entity":  entity-match
}}}

Matching for the string, integer, float, and Boolean are all of the form that a single value or a list of values of the specified type. If a list is supplied, a match is found if any element of the list matches. For entity matches, the structure is a subset of the structure for entity instances, excluding the time and document constraints.

{{{
"entity": {
    "id": [string],
}
}}}

_id_ matches on the canonical entity identifier


=== Matching on document and source aspects ===

_document_ matches on aspects of the document in which the instance was found, or aspects of the source the document was received from. It has the following structure:

{{{
"document": {
    "id": [string],
    "published": time-range,
    "downloaded": time-range,
    "source": source-constraints
}
}}}

_id_ matches on document identifiers. An identifier is a string, and is a system defined identification of the document. The value of the parameter must be an string or a list of strings. The parameter matches if the document identifier matches one of the provided identifiers. You’ll usually match on document identifiers only when you’re looking for detailed instance information using identifiers returned in the results of earlier queries.

_published_ matches on the publication date of the document. The value is a time-range structure:

{{{
{
    "min": time-spec,
    "max": time-spec
}
}}}

If _published_ is not specified, there is no constraint on the document publication time. If _min_ is specified, the publication time must not be earlier than the given time. If _max_ is specified, the publication time must not be later than the given time. The time must be specified as a string with the date format YYYY-MM-DD or YYYY-MM-DDTHH:MM:SS.000Z in UTC. It is possible to specify time with only initial portions of the time specification. That is, a timestamp can be specified as "2012-05" to indicate May, 2012, or "2012-05-01 12:00" to indicate noon, UTC on 2012-05-01.

_downloaded_ matches on the date Recorded Future downloaded the document. _downloaded_ has the same structure as _published_.

The source constraint has the following structure:

{{{
"source": {
    "id": [string],
    "name": [string],
    "topic": [string],
    "media_type": [string],
    "country": [string]
}
}}}

_id_ matches on source identifiers. An identifier is a string, and is a system defined identification of a source. The value of the parameter must be a string or a list of strings. The parameter matches if the source identifier matches one of the provided identifiers.

_name_ matches on source name. A source name is a short string identifying the source. The value of the parameter must be a string or a list of strings. The parameter matches if the source name matches one of the supplied names.

_description_ matches on source descriptions. A source description is a somewhat longer string identifying the source. The value of the parameter must be a string or a list of strings. The parameter matches if the source description matches one of the provided names.

_topic_ matches on source topics. (Recorded Future categorizes all Sources into topics.) The value of the parameter must be a string or a list of strings. The parameter matches if the source topic matches one of the following names:

<font face="Courier">Business</font><br>
<font face="Courier">Technology</font><br>
<font face="Courier">General</font><br>
<font face="Courier">Geopolitical</font><br>
<font face="Courier">Energy</font><br>
<font face="Courier">Legal</font><br>
<font face="Courier">Healthcare</font><br>
<font face="Courier">Government</font><br>
<font face="Courier">Military</font><br>
<font face="Courier">Financial services</font><br>
<font face="Courier">Health care</font><br>
<font face="Courier">Humanitarian</font><br>
<font face="Courier">Environment</font><br>
<font face="Courier">InfoSec</font><br>
<font face="Courier">terrorism</font><br>
<font face="Courier">disease</font><br>
<font face="Courier">health</font><br>
<font face="Courier">ISVG</font><br>
<font face="Courier">Malware</font>

_media`_`type_ matches on source media types. (The system categorizes all Sources into media types.) The value of the parameter must be a string or a list of strings. _media`_`type_ matches if the source media type matches one of the following names:

<font face="Courier">Blog</font><br>
<font face="Courier">Niche</font><br>
<font face="Courier">Mainstream</font><br>
<font face="Courier">Government</font><br>
<font face="Courier">NGO</font><br>
<font face="Courier">News_agency</font><br>
<font face="Courier">Exchange</font><br>
<font face="Courier">Primary_source</font><br>

_country_ matches on the originating country of the source. The value of _country_ must be a string or a list of strings. _country_ matches if the source country matches one of the country names specified in the metadata document.

=== Matching on free text ===

The "freetext" section allows you to match on free text features of an instance.
Fields available for free text search include the document title and instance
fragment. A free text specification looks like this.
{{{
"freetext": [["aa","bb"], ["cc","dd"]]
}}}

This will match instances which contain the string ("aa" OR "bb") AND ("cc" OR "dd"). 


===Entity details===

The "_entity_details_" section is a dictionary keyed by entity type name, and the values are lists of the attribute names that should be included in the output. The type, name and momentum are given for all entities. Some attributes are entity attributes, and they may be followed recursively to a certain maximum depth. The default depth is 2, which returns entity information for entities listed as attributes of instances that meet the initial query criteria. You can change the default by setting the depth parameter in the output section.  If set to 0, no entity details are given, and if set to -1, there is no depth limit.


=== Response Specification Options ===
{{{
"output": {
  "format":string,
  "timezone":string
}
}}}

_type_ defines the shape of the output response, it can be either "csv" or "json". It is "json" by default.
_timezone_ defines the timezone used to format the response items. Default is to format in UTC. 

= Output fields = 
Available output fields include

|| *Field name* || *Description* ||
|| "id" || The identity number of the instance ||
|| "type" || The name of the type of the instance ||
|| "time" || Start and stop time of the instance ||
|| "time_fragment" || The text fragment from which the time was derived ||
|| "time_fragment_context" || A larger context of the time fragment ||
|| "fragment" || The text fragment this instance was found in ||
|| "momentum || The momentum value of this instance, a value between 0 and 1. For aggregate queries, this is the average momentum. ||
|| "sentiment" || The list of sentiments of this instance, either "positive" or negative". ||
|| "attributes" || The attributes of this instance. The attributes with basic types are given inline. The entity attributes are given as references to the entity identifiers. <br>The entities themselves are given in a separate dictionary, with the string form of the entity identifier as the key, and the entity details as the value. ||
|| "canonical.id" || The identity number of the canonical item of this instance ||
|| "hits" || The number of times a canonical id has been previously observed when a record is created. ||
|| "document.id" || The identity number of the document ||
|| "document.title" || The title of the document ||
|| "document.url" || The URL of the document ||
|| "document.published" || The point in time when the document was published by the source ||
|| "document.downloaded" || The point in time when the document was downloaded ||
|| "document.sourceId.id" || The identity number of the source ||
|| "document.sourceId.name" || The name of the source ||
|| "document.sourceId.media_type" || The media type of the source ||
|| "document.sourceId.topic" || The source topic ||
|| "document.sourceId.country" || The originating country of the source ||


=== Response specification ===

Responses are returned as a structured JSON string or as CSV, as defined in the output section of the query. A JSON response has the following structure:

{{{
{
  "status": <"SUCCESS" or "FAILURE">
  "error": <describes the problem in case of FAILURE>
  "instances": <list of matching events instances, in decreasing momentum order>
  "entities": <a dictionary with details for entities involved in the events>
}
}}}


If the query is successful, the format will be what is specified by the user. If the query is unsuccessful, a JSON formatted error message will be returned.

== Aggregate Queries ==

Functionality is deprecated

= On the fly aggregation = 
These aggregates are not pre-calculated, but instead calculated on the fly. The aggregates are formed as a normal instance query, but with a aggregation specification in the output section. No limit spec is needed, the API will aggregate all matching instances.

The aggregate are much quicker than fetching instance details and aggregating on the client side, but still it will take some time for very wide aggregates, which match many millions of instances.

The output count specification should be a list of dictionaries with the keys axis and values. 

The axis specification defines what to aggregate on. It is specified by providing a sequence of the various axis choices. It could also be empty, meaning that a total aggregate should be produced. The axis choices are:
|| *Axis name* || *Axis Description* || 
|| type || The metadata type for an instance || 
|| source || The source ID of the instance's document ||
|| source_topic || The topic of the source of the instance's document ||
|| source_media_type || The media type of the source of the instance's document ||
|| source_country || The country of the source of the instance's document ||
|| document || The ID of the instance's document ||
|| canonic || The canonic ID of the instance ||
|| tempus || The tempus of the instance: either 'historic' or 'prediction' ||
|| publication_minute || The minute of publication of the document ||
|| publication_hour || The hour of publication of the document ||
|| publication_day || The day of publication of the document ||
|| publication_month || The month of publication of the document ||
|| publication_year || The year of publication of the document ||
|| publication_month_in_year || The month of a year of publication of the document ||
|| publication_day_in_month || The day in a month of publication of the document ||
|| publication_weekday || The weekday of publication of the document ||
|| start_minute || The minute of the instance start time ||
|| start_hour || The hour of the instance start time ||
|| start_day || The day of the instance start time ||
|| start_month || The month of the instance start time ||
|| start_year || The year of the instance start time ||
|| start_month_in_year || The month of a year of the instance start time ||
|| start_day_in_month || The day in a month of the instance start time ||
|| start_weekday || The weekday of the instance start time ||
|| stop_minute || The minute of the instance stop time ||
|| stop_hour || The hour of the instance stop time ||
|| stop_day || The day of the instance stop time ||
|| stop_month || The month of the instance stop time ||
|| stop_year || The year of the instance stop time ||
|| stop_month_in_year || The month of a year of the instance stop time ||
|| stop_day_in_month || The day in a month of the instance stop time ||
|| stop_weekday || The weekday of the instance stop time ||
|| loader || The origin of the document (mostly of internal interest) ||
 
The values specification defines what should be calculated for each time point for the axis. The specification should be a list of dictionary entries, each with a key 'type' defining which value type is requested. The allowed values are:

|| *Count type* || *Value Description* ||
|| instances || The number of matching instances ||
|| documents || The number of distinct documents for the matching instances ||
|| momentum || The average momentum for the matching instances ||
|| sentiment || The sentiments for the matching instances ||

A sentiment entry has two required keys:

|| *Sentiment type key* || *Key options and meaning* || 
|| kind	|| Either general or finance, to choose on of the two sentiment kinds ||
|| style ||	Either combined (positive-negative), positive, or negative ||

The output format defaults to JSON, but can be changed to CSV by setting the format key in the output section to csv.
 
Example:
{{{
{
  "instance": {
    "attributes": {"entity": {"id": "B_LyO"}},
    "document": {
      "published": {"min": "2011-04", "max": "2011-05"}
    }
  },
  "output": {
    "count": [{"axis": ["publication_day", "source_media_type"],
               "values": [{"type": "instances"}, 
                          {"type": "sentiment", 
                           "kind": "general", "style": "combined"}, 
                          {"type": "momentum"}]}],
     "format": "csv"
  },
  "token": "TOKEN"
}
}}}

Here is a sample CSV output of this query. It shows the first few lines of the response.
{{{
publication_day,source_media_type,instances,general_combined,momentum
2011-04-01,Blog,611,0.0,0.38483444
2011-04-01,Mainstream,123,0.0,0.37988955
2011-04-01,News Agency,154,0.0,0.3903726
2011-04-01,Niche,348,0.0,0.41963947
2011-04-01,Primary Source,3,0.0,0.3637922
2011-04-02,Blog,283,0.0,0.4196129
2011-04-02,Mainstream,55,0.0,0.4168904
2011-04-02,News Agency,45,0.0,0.4575829
2011-04-02,Niche,59,0.0,0.4094747
...
}}}

Here is the corresponding JSON output:
{{{
{
  "status": "SUCCESS", 
  "counts": [
    {
      "2011-04-13": {
        "Niche": {
          "instances": 268, 
          "momentum": 0.4584336, 
          "general_combined": 0.0
        }, 
        "Primary Source": {
          "instances": 1, 
          "momentum": 0.39325377, 
          "general_combined": 0.0
        }, 
        "Mainstream": {
          "instances": 182, 
          "momentum": 0.45799348000000001, 
          "general_combined": 0.0
        }, 
...
}}}

= Paging instance results =
	
The default limit of the number of resulting instances in an instance query is 100. The limit can be explicitly set as described above, up to a maximum of 100 000 instances. Sometimes, it’s hard to know how many instances a query will result in, and sometimes it’s desirable to be able to page through the, possibly very large, result set. 

If not all instances matching a query are returned by the API, due to the response exceeding the implicit or explicit instance limit, the JSON response will contain the key next_page_start with an opaque value. If CSV output is requested there is no place in the output for this information, so instead the HTTP response header RFQ-next_page_start is set to the opaque value. In order to get the next set of matching instances (the next page), the same query should be executed again, with the instance query key page_start set to the value of the last next_page_start.

To get all matching instances of a query, this process should be repeated until next_page_start is not set in a query response.


== Examples ==

== Query Examples ==

This section contains several sample queries.

Example: Mergers and Acquisitions

{{{
{
  "comment": "Mergers or Acquisitions involving Apple or Google, published last year",
  "instance": {
    "type": ["Merger","Acquisition"],
    "attributes": {
        "entity": {
          "attributes": {"id": ["B_LyO", "B_HE4"]}
        }
      },
    "document": {
      "published": {"min": "2011-01-01", "max": "2011-12-31"}
    },
    "limit": 200
  },
  "token": "ABCDEF"
}
}}}

Example: Future Events
{{{
{
	"comment": "Search for events involving Apple beginning after a particular date.",
	"instance": {
	    "attributes": {
	        "entity":{
	            "id": "B_LyO"
	        }
	    },
		"start_time": "2012-10-01",
		"limit":1000
	},
	"token": "YOURTOKEN"
}
}}}

Example: Quotations

{{{
{
  "comment": "Barack Obama quotations.",
  "instance": {
    "type": "Quotation",
    "attributes": {
      "entity": {
        "id":"B_FCc"
      }
    },
    "limit": 3
  },
  "token": "ABCDEF"
}
}}}


Example: Search for Entity Instances

{{{
{
  "instance": {
    "type": "EntityOccurrence",
    "attributes": {
      "entity": {
        "id": "B_FCc"
      }
    }
    "document": {
      "published": {"min": "2010-01-01", "max": "2010-02-01"}
    },
    "limit": 5
  },
  "token": "TOKEN"
 }
}}}


Example: Search for calendar events

{{{
{
 "instance": {
   "type": ["EconomicEvent"],
   "start_time": "2008-09-01",
   "stop_time": "2008-10-01",
   "limit": 10
 },
 "token": "TOKEN"
}
}}}

Example: List and search by Bloomberg ID.
The following query will give a list of all entities that have the Bloomberg ID attribute.
{{{
{
  "entity": {
    "attributes": {
      "name": "external_links.bloomberg.id",
      "exists": true
    }
  },
  "token": "TOKEN"
}
}}}
You can also find an entity based on its Bloomberg ID. 
{{{
{
  "entity": {
    "attributes": {
      "name": "external_links.bloomberg.id",
      "string": "BLOOMBERG_ID"
    }
  },
  "token": "TOKEN"
}
}}}

Example: Finding instances matching a given text fragment.
{{{
{
  "instance": {
    "fragment":"FRAGMENT OF TEXT TO SEARCH"
  },
  "token": "TOKEN"
}
}}}

=== Response Example ===

The following sample is the complete response to the query in the Quick Start section earlier in this document:

{{{
{
  "status": "SUCCESS", 
  "next_page_start": "BMxYxngYAAT", 
  "entities": {
    "I50Cdo": {
      "hits": 0, 
      "name": "Computing", 
      "level": 2, 
      "artificial_hits": 1, 
      "type": "Technology", 
      "momentum": 0.0
    }, 
    "I50PbO": {
      "hits": 0, 
      "name": "Electronics", 
      "level": 2, 
      "artificial_hits": 1, 
      "type": "Technology", 
      "momentum": 0.0
    }, 
    "I50Cbm": {
      "hits": 0, 
      "name": "Embedded Systems", 
      "level": 1, 
      "artificial_hits": 1, 
      "type": "Technology", 
      "momentum": 0.0
    }, 
    "I50CIl": {
      "hits": 0, 
      "name": "Mobile Telecommunications", 
      "level": 1, 
      "artificial_hits": 1, 
      "type": "Technology", 
      "momentum": 0.0
    }, 
    "CAKQv": {
      "gender": "female", 
      "hits": 367, 
      "type": "Person", 
      "name": "Katherine Egbert", 
      "momentum": 0.00021622619337531262
    }, 
    "Fa68V": {
      "hits": 0, 
      "type": "Industry", 
      "name": "Investment Advice", 
      "momentum": 0.0
    }, 
    "Fa68W": {
      "hits": 0, 
      "type": "Industry", 
      "name": "Security Brokers And Dealers", 
      "momentum": 0.0
    }, 
    "I6fXb1": {
      "hits": 0, 
      "type": "Industry", 
      "name": "Financial Services", 
      "momentum": 0.0
    }, 
    "B_E5W": {
      "hits": 685949, 
      "type": "Position", 
      "name": "analyst", 
      "momentum": 0.20859941944640195
    }, 
    "B_E7B": {
      "industries": [
        "I6fXbb", 
        "I6fXcA"
      ], 
      "cusip": [
        "594918104"
      ], 
      "hits": 847780, 
      "name": "Microsoft", 
      "cik": [
        "0000934520", 
        "0000789019"
      ], 
      "gics": [
        "Information Technology"
      ], 
      "sedol": [
        "2588173"
      ], 
      "tickers": [
        "MSFT"
      ], 
      "type": "Company", 
      "momentum": 0.098418519773185109
    }, 
    "B_39n": {
      "hits": 18523, 
      "type": "Product", 
      "name": "Zune", 
      "momentum": 0.0088600902052855552
    }, 
    "Fa7In": {
      "hits": 0, 
      "type": "Industry", 
      "name": "Security/commodity Services Nec", 
      "momentum": 0.0
    }, 
    "I6fXcA": {
      "hits": 0, 
      "type": "Industry", 
      "name": "Computer Software", 
      "momentum": 0.0
    }, 
    "B_E5e": {
      "category": [
        "B_E5e", 
        "I50Cdo"
      ], 
      "hits": 163254, 
      "name": "Operating System", 
      "level": 0, 
      "type": "Technology", 
      "momentum": 0.12269314225948348
    }, 
    "I6fXbv": {
      "hits": 0, 
      "type": "Sector", 
      "name": "Financials", 
      "momentum": 0.0
    }, 
    "CIDRS": {
      "category": [
        "I50PbO", 
        "I50CbT", 
        "I50CaG", 
        "B_E5e", 
        "I50Cdo", 
        "I50CIl", 
        "I50CJQ", 
        "I50Cal", 
        "I50Cbm", 
        "CIDRS", 
        "I50CcL"
      ], 
      "hits": 678199, 
      "name": "Smartphone", 
      "level": 0, 
      "type": "Technology", 
      "momentum": 0.38571638776420558
    }, 
    "I2uOyU": {
      "industries": [
        "Fa7FE", 
        "Fa68W", 
        "Fa68V", 
        "I6fXbv", 
        "I6fXb1", 
        "Fa7In"
      ], 
      "hits": 523, 
      "name": "Jefferies", 
      "cik": [
        "0001084580"
      ], 
      "longname": "Jefferies Asset Management LLC", 
      "tickers": [
        "JEF"
      ], 
      "type": "Company", 
      "momentum": 0.010796735942465212
    }, 
    "I50Cal": {
      "hits": 0, 
      "name": "Consumer Electronics", 
      "level": 1, 
      "artificial_hits": 1, 
      "type": "Technology", 
      "momentum": 0.0
    }, 
    "I6fXbb": {
      "hits": 0, 
      "type": "Sector", 
      "name": "Information Technology", 
      "momentum": 0.0
    }, 
    "Fa7FE": {
      "hits": 0, 
      "type": "Industry", 
      "name": "Holding Companies, Nec", 
      "momentum": 0.0
    }, 
    "I50CcL": {
      "hits": 0, 
      "name": "Information Appliances", 
      "level": 1, 
      "artificial_hits": 1, 
      "type": "Technology", 
      "momentum": 0.0
    }, 
    "I50CbT": {
      "hits": 0, 
      "name": "Mobile Phone Manufacturers", 
      "level": 1, 
      "artificial_hits": 1, 
      "type": "Technology", 
      "momentum": 0.0
    }, 
    "I50CJQ": {
      "hits": 0, 
      "name": "Mobile Operating Systems", 
      "level": 1, 
      "artificial_hits": 1, 
      "type": "Technology", 
      "momentum": 0.0
    }, 
    "I50CaG": {
      "hits": 0, 
      "name": "Mobile Phone Culture", 
      "level": 1, 
      "artificial_hits": 1, 
      "type": "Technology", 
      "momentum": 0.0
    }
  }, 
  "instances": [
    {
      "hits": 75, 
      "tagged_fragment": "<e id=I2uOyU>Jefferies & Company</e> <e id=B_E5W>analyst</e> <e id=CAKQv>Katherine Egbert</e> has stated that <e id=CAKQv>she</e> believes <i id=F5ybmW><e id=B_E7B>Microsoft</e> would launch their own <e id=B_39n>Zune</e> branded <e id=CIDRS>smartphone</e> in the <t>next two months</t></i>.", 
      "time_fragment_context": "Microsoft Zune Phone might arrive in 2 months Jefferies & Company analyst Katherine Egbert has stated that she believes Microsoft would launch their own Zune branded smartphone in the next two months.", 
      "fragment": "Microsoft Zune Phone might arrive in 2 months Jefferies & Company analyst Katherine Egbert has stated that she believes Microsoft would launch their own Zune branded smartphone in the next two months.", 
      "time_fragment": "next two months", 
      "stop": "2010-03-20T23:59:59.000Z", 
      "item_fragment": "Microsoft would launch their own Zune branded smartphone in the next two months", 
      "precision": "day", 
      "start": "2010-01-20T00:00:00.000Z", 
      "time_type": "during", 
      "attributes": {
        "status": "announced", 
        "product": "B_39n", 
        "product_type": "Electronics", 
        "positive": 0.0, 
        "company": "B_E7B", 
        "negative": 0.0, 
        "date_string": "in the next two months", 
        "document_category": "Technology_Internet"
      }, 
      "document": {
        "language": "eng", 
        "title": "Microsoft Zune Phone might arrive in 2 months", 
        "sourceId": {
          "name": "Techwhack.com", 
          "country": "United States of America", 
          "topic": "Technology", 
          "media_type": "Blog", 
          "id": "Po", 
          "description": "Techwhack.com"
        }, 
        "downloaded": "2010-01-20T09:55:27.000Z", 
        "url": "http://business.techwhack.com/6010-microsoft-zune-phone", 
        "published": "2010-01-20T05:02:59.000Z", 
        "id": "Qm4n"
      }, 
      "type": "ProductRelease", 
      "id": "GLGM8DAHapc", 
      "momentum": 0.55193171608265945, 
      "canonical": {
        "id": "KdDaGFvdLR"
      }
    }
  ]
}
}}}


== Using the Recorded Future API with R ==

[http://www.r-project.org/ R] is a language and environment for statistical computing and graphics. You can use commonly- available R packages to assist with forming and executing queries, and obtaining and parsing the results.

The [http://www.omegahat.org/RJSONIO/ RJSONIO Package] contains functions that facilitate reading and writing JSON data:

* The _fromJSON_ function converts a JSON string into R list objects.
* The _toJSON_ function converts R list objects into a JSON string.

The following sample shows a Recorded Future query as a standard R list object with two top level elements:  instance and output.
{{{
>print(Rquery)

$instance
$instance$type
[1] "ProductRelease"

$instance$attributes
$instance$attributes[[1]]
$instance$attributes[[1]]$type
[1] "Company"

$instance$document
$instance$document$published
$instance$document$published$min
[1] "2010-01-01"

$instance$document$published$max
[1] "2010-03-12"

 $instance$limit
[1] 1

}}}

To create a JSON string, apply the toJSON function to this R list object:

{{{
> json.Query<-toJSON(Rquery)

> cat(json.Query)
}}}

The following sample shows the resulting JSON string:

{{{
{
    "instance": {
        "type": ["ProductRelease"],
        "attributes": [{"type": "Company",
                    "entity": {"attributes": [{"name": "gics",
                                    "string": "Information Technology"}]}}],
        "document": {
            "published": {"min": "2010-01-01", "max": "2010-03-12"}
        },
        "limit": 1
    }
}
}}}

The [http://www.omegahat.org/RCurl/ RCURL Package] is an R-interface to the [http://curl.haxx.se/ libcurl] library. This package assists with creating and submitting URLs that contain the JSON formatted query and with retrieving the results from the response.

The following sample uses RCURL routines to form a URL and retrieve data and then uses the fromJSON function from the RJSONIO package to create the resulting R list objects.

{{{
> opts = curlOptions(header = FALSE)

> url<-paste("http://api.recordedfuture.com/query?q=", RCurl::curlEscape(jsonQuery),sep="")

> jsonResult<-getBinaryURL(url, .opts = opts)

> jsonResult <-fromJSON(jsonResult)
}}}

== Using the Recorded Future API with Python ==

A number of Python libraries are available to facilitate reading and writing JSON data, including the popular [http://www.undefined.org/python/ simplejson] and [http://sourceforge.net/projects/json-py/ json-py].

The following sample Python code executes two queries and prints some of the results. If you test this sample by incorporating it into your code, remember to replace the value TOKEN with a valid Recorded Future API token.

{{{
#Sample Python query:

#----------------------------------------------

qsource2="""{
  "comment": "Barack Obama quotations.",
  "instance": {
    "type": "Quotation",
    "attributes": {
      "entity": {
        "id":"B_FCc"
      }
    },
    "limit": 3
  },
  "token": "ABCDEF"
}"""

qsource="""{

  "comment": "Q1 earnings calls",

  "instance": {
    "type": ["ConferenceCall"],
    "attributes": [ {"name": "year", "string": "2009"},
    "limit": 50,
    "document": {
      "source": {
         "topic": "Business"
      }
    }
  },
  "token": "TOKEN"

}""" 
}}}

The following Python sample makes use of the Recorded Future event instances web service.

{{{
#-------------------------------------------------------
#Python example that takes query and executes
#------------------------------------------------------
import sys, urllib, json

# Simple program showing how to use the event instances web-service from Python

# Web service URL
url = 'http://api.recordedfuture.com/query?%s'

# Wraps the web-service into a python function
# Input: q: a JSON-formatted string specifying the query
# Out: Dict corresponding to the JSON object returned by the web service
def query(q):
    try:
        data = urllib.urlopen(url % urllib.urlencode({"q":q}))
        if type(data) != str:
            data = data.read()
        #print data
        return json.loads(data)
    except Exception, e:
        return {'status': 'FAILURE', 'errors': str(e)}

# Main program code:
# Open a specified query file (JSON-formatted), and run that query
# The result is a list of event instances matching the query, ordered by momentum
# and a dictionary with detailed information about the involved entities

# Read the query
qsource = open(sys.argv[1], "r").read()

# Run the query
res = query(q=qsource)
print(str(res))

# Check if the query succeeded
if res['status'] == 'FAILURE':
    print("Error: " + str(res['errors']))
    sys.exit(1)

# Get the returned structures
entities = res["entities"]
evis = res["instances"]

# Utility function to pretty print an entity overview (name and type)
def eninfo(en):
    return "%s[%s]" % (en["name"], en["type"])

def utf8(s):
    return s.encode('utf-8') if type(s) in [unicode, str] else s

# Iterate of the event instances
for evi in evis:  
    # Print basic event instance info (type and time)
    print (evi["type"], evi["start"], "-", evi["stop"])

       # Print the event roles and their values
    for k, v in evi["attributes"].items():
        # No metadata available here, so use a simple method to check if
        # the value is an entity reference: try to look it up in the
        # entity dictionary
        if type(v) in [long, int]:
            en = entities.get(str(v))
            if en:
                v = eninfo(en)
        print ("  %s=%s" % (k, v))
    # Print anonymous entity references (not tied to a role) in the event instance
    v = evi.get("mentions")
    if v:
        v = v if type(v) == list else [v]
        print ("  mentions=%s" % ", ".join([eninfo(entities[str(enid)]) for enid in v]))

    # Print document information
    doc = evi["document"]
    print ("  document:")
    for key in ["title", "sourceId", "url"]:
            print ("    %s=%s" % (key, utf8(doc[key])))

print ("\nDetails about involved entities:\n")

for id, en in entities.items():
    print (eninfo(en), "(id=" + str(id) + ")")
    for k, v in en.items():
        if k in ["name", "type"]:
            continue
        print ("  %s=%s" % (k, v))
}}}

== Entity and Event Types ==

The following event and entity types are currently available in the system.

=== Entity Types ===

<font face="Courier">Anniversary</font><br>
<font face="Courier">City</font><br>
<font face="Courier">Commodity</font><br>
<font face="Courier">Company</font><br>
<font face="Courier">Continent</font><br>
<font face="Courier">Country</font><br>
<font face="Courier">Coup</font><br>
<font face="Courier">CreditCardNumber</font><br>
<font face="Courier">Currency</font><br>
<font face="Courier">CurrencyPair</font><br>
<font face="Courier">CyberAttackCampaign</font><br>
<font face="Courier">CyberVulnerability</font><br>
<font face="Courier">EconomicIndicator</font><br>
<font face="Courier">EmailAddress</font><br>
<font face="Courier">EntertainmentAwardEvent</font><br>
<font face="Courier">EntityList</font><br>
<font face="Courier">Facility</font><br>
<font face="Courier">FaxNumber</font><br>
<font face="Courier">Feature</font><br>
<font face="Courier">FileName</font><br>
<font face="Courier">GeoEntity</font><br>
<font face="Courier">Hash</font><br>
<font face="Courier">Holiday</font><br>
<font face="Courier">Identifier</font><br>
<font face="Courier">Industry</font><br>
<font face="Courier">IndustryTerm</font><br>
<font face="Courier">InternetDomainName</font><br>
<font face="Courier">IpAddress</font><br>
<font face="Courier">Malware</font><br>
<font face="Courier">MalwareSignature</font><br>
<font face="Courier">MarketIndex</font><br>
<font face="Courier">MedicalCondition</font><br>
<font face="Courier">MedicalTreatment</font><br>
<font face="Courier">Movement</font><br>
<font face="Courier">Movie</font><br>
<font face="Courier">MusicAlbum</font><br>
<font face="Courier">MusicGroup</font><br>
<font face="Courier">NaturalFeature</font><br>
<font face="Courier">OperatingSystem</font><br>
<font face="Courier">Operation</font><br>
<font face="Courier">OrgEntity</font><br>
<font face="Courier">Organization</font><br>
<font face="Courier">Person</font><br>
<font face="Courier">PhoneNumber</font><br>
<font face="Courier">Position</font><br>
<font face="Courier">Product</font><br>
<font face="Courier">ProgrammingLanguage</font><br>
<font face="Courier">ProvinceOrState</font><br>
<font face="Courier">PublishedMedium</font><br>
<font face="Courier">RadioProgram</font><br>
<font face="Courier">RadioStation</font><br>
<font face="Courier">Region</font><br>
<font face="Courier">Religion</font><br>
<font face="Courier">ReportingEntity</font><br>
<font face="Courier">Sector</font><br>
<font face="Courier">Source</font><br>
<font face="Courier">SourceMediaType</font><br>
<font face="Courier">SportsEvent</font><br>
<font face="Courier">SportsGame</font><br>
<font face="Courier">SportsLeague</font><br>
<font face="Courier">TVShow</font><br>
<font face="Courier">TVStation</font><br>
<font face="Courier">Technology</font><br>
<font face="Courier">TechnologyArea</font><br>
<font face="Courier">Topic</font><br>
<font face="Courier">TwitterHandle</font><br>
<font face="Courier">URL</font><br>
<font face="Courier">Username</font><br>

<font face="Courier">WinRegKey</font><br>

=== Event Types ===

<font face="Courier">Acquisition</font><br>
<font face="Courier">Alliance</font><br>
<font face="Courier">AnalystEarningsEstimate</font><br>
<font face="Courier">AnalystRecommendation</font><br>
<font face="Courier">Announcement</font><br>
<font face="Courier">ArmedAssault</font><br>
<font face="Courier">ArmedAttack</font><br>
<font face="Courier">ArmsPurchaseSale</font><br>
<font face="Courier">Arrest</font><br>
<font face="Courier">Arson</font><br>
<font face="Courier">Bankruptcy</font><br>
<font face="Courier">BeneficialOwnershipFiling</font><br>
<font face="Courier">BiologicalTerrorism</font><br>
<font face="Courier">Bombing</font><br>
<font face="Courier">BonusSharesIssuance</font><br>
<font face="Courier">BusinessRelation</font><br>
<font face="Courier">BusinessTransaction</font><br>
<font face="Courier">BusinessTransactionText</font><br>
<font face="Courier">Buybacks</font><br>
<font face="Courier">CandidatePosition</font><br>
<font face="Courier">Ceasefire</font><br>
<font face="Courier">ChemicalTerrorism</font><br>
<font face="Courier">CivilCourtProceeding</font><br>
<font face="Courier">ClinicalTrial</font><br>
<font face="Courier">CoEntityText</font><br>
<font face="Courier">CoOccurrence</font><br>
<font face="Courier">CompanyAccountingChange</font><br>
<font face="Courier">CompanyAffiliates</font><br>
<font face="Courier">CompanyCompetitor</font><br>
<font face="Courier">CompanyCustomer</font><br>
<font face="Courier">CompanyEarningsAnnouncement</font><br>
<font face="Courier">CompanyEarningsGuidance</font><br>
<font face="Courier">CompanyEmployeesNumber</font><br>
<font face="Courier">CompanyExpansion</font><br>
<font face="Courier">CompanyForceMajeure</font><br>
<font face="Courier">CompanyFounded</font><br>
<font face="Courier">CompanyInvestment</font><br>
<font face="Courier">CompanyLaborIssues</font><br>
<font face="Courier">CompanyLayoffs</font><br>
<font face="Courier">CompanyLegalIssues</font><br>
<font face="Courier">CompanyListingChange</font><br>
<font face="Courier">CompanyLocation</font><br>
<font face="Courier">CompanyMeeting</font><br>
<font face="Courier">CompanyNameChange</font><br>
<font face="Courier">CompanyProduct</font><br>
<font face="Courier">CompanyReorganization</font><br>
<font face="Courier">CompanyRestatement</font><br>
<font face="Courier">CompanyTechnology</font><br>
<font face="Courier">CompanyTicker</font><br>
<font face="Courier">CompanyUsingProduct</font><br>
<font face="Courier">ConferenceCall</font><br>
<font face="Courier">Conviction</font><br>
<font face="Courier">CreditRating</font><br>
<font face="Courier">CrimeAndViolence</font><br>
<font face="Courier">CriminalCourtProceeding</font><br>
<font face="Courier">CyberAttack</font><br>
<font face="Courier">Cyberterrorism</font><br>
<font face="Courier">DatedEvent</font><br>
<font face="Courier">DebtFinancing</font><br>
<font face="Courier">DelayedFiling</font><br>
<font face="Courier">DiplomaticRelations</font><br>
<font face="Courier">DiseaseOutbreak</font><br>
<font face="Courier">Dividend</font><br>
<font face="Courier">EconomicEvent</font><br>
<font face="Courier">Election</font><br>
<font face="Courier">EmploymentChange</font><br>
<font face="Courier">EmploymentRelation</font><br>
<font face="Courier">EntityOccurrence</font><br>
<font face="Courier">EnvironmentalIssue</font><br>
<font face="Courier">EquityFinancing</font><br>
<font face="Courier">ExtendedPatentFiling</font><br>
<font face="Courier">Extinction</font><br>
<font face="Courier">FDAPhase</font><br>
<font face="Courier">FamilyRelation</font><br>
<font face="Courier">FinancialFiling</font><br>
<font face="Courier">GeoPolitical</font><br>
<font face="Courier">Hijacking</font><br>
<font face="Courier">HostageRelease</font><br>
<font face="Courier">HostageTakingKidnapping</font><br>
<font face="Courier">IPO</font><br>
<font face="Courier">IndicesChanges</font><br>
<font face="Courier">Indictment</font><br>
<font face="Courier">InsiderTransaction</font><br>
<font face="Courier">JointVenture</font><br>
<font face="Courier">LocatedEvent</font><br>
<font face="Courier">LocationEvent</font><br>
<font face="Courier">ManMadeDisaster</font><br>
<font face="Courier">Merger</font><br>
<font face="Courier">MilitaryAction</font><br>
<font face="Courier">MilitaryManeuver</font><br>
<font face="Courier">MilitaryOperation</font><br>
<font face="Courier">MiscTerrorism</font><br>
<font face="Courier">MnA</font><br>
<font face="Courier">MovieRelease</font><br>
<font face="Courier">MusicAlbumRelease</font><br>
<font face="Courier">NaturalDisaster</font><br>
<font face="Courier">NuclearMaterialTransaction</font><br>
<font face="Courier">NuclearTerrorism</font><br>
<font face="Courier">PatentFiling</font><br>
<font face="Courier">PatentIssuance</font><br>
<font face="Courier">PersonAttributes</font><br>
<font face="Courier">PersonCareer</font><br>
<font face="Courier">PersonCommunication</font><br>
<font face="Courier">PersonEducation</font><br>
<font face="Courier">PersonEmailAddress</font><br>
<font face="Courier">PersonLocation</font><br>
<font face="Courier">PersonMeeting</font><br>
<font face="Courier">PersonParty</font><br>
<font face="Courier">PersonRelation</font><br>
<font face="Courier">PersonThreat</font><br>
<font face="Courier">PersonTravel</font><br>
<font face="Courier">PoliceOperation</font><br>
<font face="Courier">PoliticalEndorsement</font><br>
<font face="Courier">PoliticalEvent</font><br>
<font face="Courier">PoliticalRelationship</font><br>
<font face="Courier">PollResult</font><br>
<font face="Courier">PressRelease</font><br>
<font face="Courier">ProductIssues</font><br>
<font face="Courier">ProductRecall</font><br>
<font face="Courier">ProductRelease</font><br>
<font face="Courier">Quotation</font><br>
<font face="Courier">QuotationText</font><br>
<font face="Courier">RFEVEAcquisition</font><br>
<font face="Courier">RFEVEArmedAssault</font><br>
<font face="Courier">RFEVEIedExplosion</font><br>
<font face="Courier">RFEVELegislation</font><br>
<font face="Courier">RFEVEMalwareThreat</font><br>
<font face="Courier">RFEVEMerger</font><br>
<font face="Courier">RFEVEOrganizationRelationship</font><br>
<font face="Courier">RFEVEPersonCareer</font><br>
<font face="Courier">RFEVEPersonCommunication</font><br>
<font face="Courier">RFEVEPoliticalRelationship</font><br>
<font face="Courier">RFEVEProtest</font><br>
<font face="Courier">RadiologicalMaterialTransaction</font><br>
<font face="Courier">Robbery</font><br>
<font face="Courier">SecondaryIssuance</font><br>
<font face="Courier">SourceLocation</font><br>
<font face="Courier">Speech</font><br>
<font face="Courier">StandardEvent</font><br>
<font face="Courier">StatusEvent</font><br>
<font face="Courier">StockSplit</font><br>
<font face="Courier">TerrorCommunication</font><br>
<font face="Courier">TerrorFinancing</font><br>
<font face="Courier">Trafficking</font><br>
<font face="Courier">Trial</font><br>
<font face="Courier">Vandalism</font><br>
<font face="Courier">Visit</font><br>
<font face="Courier">VotingResult</font><br>