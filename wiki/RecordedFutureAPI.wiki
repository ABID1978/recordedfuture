= Recorded Future API =

== version 1.0.0 ==

Contents

    # *1 *[version 1.0.0#version_1.0.0]
    # <a href="#TOC-Introduction">*2 *Introduction</a>
        # <a href="#TOC-Quick-Start:-Creating-Requests.">*2.1 *Quick Start: Creating Requests.</a>
    # <a href="#TOC-Input-and-Output-in-JSON">*3 *Input and Output in JSON</a>
    # <a href="#TOC-Query-specification">*4 *Query specification</a>
        # <a href="#TOC-Matching-on-instance-identity-or-ty">*4.1 *Matching on instance identity or type</a>
        # <a href="#TOC-Matching-on-instance-time">*4.2 *Matching on instance time</a>
        # <a href="#TOC-Matching-on-the-canonical-item">*4.3 *Matching on the canonical item</a>
        # <a href="#TOC-Matching-on-attributes">*4.4 *Matching on attributes</a>
        # <a href="#TOC-Matching-on-document-and-source-asp">*4.5 *Matching on document and source aspects</a>
        # <a href="#TOC-Output-fields">*4.6 *Output fields</a>
        # <a href="#TOC-Entity-details">*4.7 *Entity details</a>
        # <a href="#TOC-Response-specification">*4.8 *Response specification</a>
    # <a href="#TOC-Aggregate-Queries">*5 *Aggregate Queries</a>
    # <a href="#TOC-Examples">*6 *Examples</a>
        # <a href="#TOC-Query-Examples">*6.1 *Query Examples</a>
        # <a href="#TOC-Response-Example">*6.2 *Response Example</a>
    # <a href="#TOC-Working-with-the-API-in-the-Recorde">*7 *Working with the API in the Recorded Future UI</a>
    # <a href="#TOC-Using-the-Recorded-Future-API-with-">*8 *Using the Recorded Future API with R</a>
    # <a href="#TOC-Using-the-Recorded-Future-API-with-1">*9 *Using the Recorded Future API with Python</a>
    # <a href="#TOC-Entity-and-Event-Types">*10 *Entity and Event Types</a>
        # <a href="#TOC-Entity-Types">*10.1 *Entity Types</a>
        # <a href="#TOC-Event-Types">*10.2 *Event Types</a>

== Introduction ==

The Recorded Future’s API enables you to build analytic applications and perform analysis which is aware of events happening around the globe 24x7, with extensive historical records. You can perform queries and receive results from the Recorded Future Temporal Analytics Engine across a vast set of events, entities, and time points spanning from the far past into the future.

Your application can come alive with real time access into the Recorded Future engine, completely aware of events as they unfold around the world - and your analysis of for example financial markets can be made aware of events involving companies, people, products, etc. Historical archives allows you to extensively backtest results.

Sample applications and analysis built/done with the Recorded Future API include
    * Interactive dashboards of global events
    * Google earth overlay of global events
    * Back testing whether FT Alphaville (high profile financial blog) is "better" than general news in predicting stock returns
    * Back testing whether Recorded Future momentum metric accurately predicts equity trading volume

To access Recorded Future through the API:
    # Request a Recorded Future API token.
    # Create a structured JSON string that describes the query.
    # Create and submit the associated URL.
    # Retrieve and parse the results.

=== Quick Start: Creating Requests. ===

Queries are sent using HTTP GET to
	[http://api.recordedfuture.com/ws/rfq/instances?q=query&compress=usecompression http://api.recordedfuture.com/ws/rfq/instances?q=query&compress=usecompression]
    
Zip compression is enabled if the optional attribute compress=usecompression. If the attribute is not set, no compression is used.

Note: Queries can also be sent using HTTP POST. Do this if the query string becomes too long (typically, there is a limit on a few thousand characters for GET requests).


Queries and responses are expressed in JSON.

The following sample query looks for Product Release events from companies within the Information Technology sector, published in January 2010. The 100 first results are returned.


{{{
{
  "instance": {
    "type": ["ProductRelease"],
    "attributes": [{"name": "company",
                    "entity": {"attributes": [{"name": "gics",
                                               "string": "Information Technology"}]}}],
    "document": {
      "published": {"min": "2010-01-01", "max": "2010-02-01"}
    },
    "limit": 100
  },
  "output": {
    "fields": ["type", "time", "fragment", "momentum", "attributes",
               "document.title", "document.url", "document.published", "source.description"]
  },
  "token": TOKEN
}
}}}


The following sample result is part of the response to the query, which contains information about one event instance. The result contains information about the event (an announced product release), the text fragment it was found in (“Microsoft launches tech policy Web site.”), the document source (Federal Computer Week News), the document it was found in (The URL that displays the actual document), and the current momentum value.

{{{
{
  "fragment": "Microsoft launches tech policy Web site.",
  "stop": "2010-01-06T17:13:31.000Z",
  "start": "2010-01-06T17:13:31.000Z",
  "attributes": {
    "status": "announced",
    "company": 33312449,
    "product_type": "Other",
    "product": 33434006
  },
  "document": {
    "url": "http://fcw.com/articles/2010/01/06/microsoft-web-technology-policy.aspx",
    "source": {
      "description": "Federal Computer Week News"
    },
    "published": "2010-01-06T17:13:31.000Z",
    "title": "Microsoft launches tech policy Web site"
  },
  "type": "ProductRelease",
  "momentum": 0.044266346260364201
}
}}}


Entities – the people, companies, organizations, and places of the Recorded Future Who/Where list – are created on-demand as they are harvested by a query. Once an entity is defined, all references to that entity are defined as entity instances that point to the underlying canonical entity. Once an entity is defined, all references to that entity are defined as entity instances that point to the underlying canonical entity. Entities are returned in a separate structure, to avoid duplication, and in the instances only references to the entities are present, using an opaque identifier. For example, in the attributes section above there is a company with the identifier 33312449. In the entity structure, there is an parameter for that identifier:
{{{
    "33312449": {
      "type": "Company",
      "name": "Microsoft",
      "momentum": 0.72911597000853101
    }
}}}

For details about the exact query and response structures, see the “Query Specification” and “Response Specification” sections.

== Input and Output in JSON ==

The Recorded Future API supports JSON as the input and output format. For a detailed JSON specification, visit Douglas Crockford’s site [http://www.json.org/ JSON.org], paying particular attention to [http://tools.ietf.org/html/rfc4627 RFC 4627]. This section provides a short excerpt.
*Tip*: If you are using [http://www.r-project.org R], you don’t need to worry about formatting JSON input or parsing JSON output. R packages manage input and output for you. See “Using the Recorded Future API with R” to learn more.
*JSON* (JavaScript Object Notation) is a lightweight data-interchange format. It is easy for humans to read and write. It is easy for machines to parse and generate. JSON is a text format that is completely language independent but uses conventions that are familiar to programmers of the C-family of languages, including C, C++, C#, Java, JavaScript, Perl, Python, and many others. These properties make JSON an ideal data-interchange language.
JSON is built on two structures:

	* A collection of name/value pairs. In various languages, this is realized as an _object_, record, struct, dictionary, hash table, keyed list, or associative array.
	* An ordered list of values. In most languages, this is realized as an _array_, vector, list, or sequence.

These are universal data structures. Virtually all modern programming languages support them in one form or another. It makes sense that a data format that is interchangeable with programming languages also be based on these structures.
In JSON, which always uses Unicode encoding, they take on these forms:

	* An _object_ is an unordered set of name/value pairs. An object begins with { <font size="-1">(left brace)</font> and ends with } <small>(right brace)</small>. Each name is followed by : <small>(colon)</small> and the name/value pairs are separated by , <small>(comma)</small>.
	* An _array_ is an ordered collection of values. An array begins with [ <small>(left bracket)</small> and ends with ] <small>(right bracket)</small>. Values are separated by , <small>(comma)</small>.
	* A _value_ can be a _string_ in double quotes, or a _number_, or true or false or null, or an _object_ or an _array_. These structures can be nested.
    * A _string_ is a collection of zero or more Unicode characters, wrapped in double quotes, using backslash escapes. A character is represented as a single character string. A string is very much like a C or Java string.
	* A _number_ is very much like a C or Java number, except that the octal and hexadecimal formats are not used.
    * Whitespace can be inserted between any pair of tokens.